# 操作系统

![image-20251217120708504](操作系统.assets/image-20251217120708504.png)



[TOC]



## 引言

### 操作系统的基本特征：并发，共享，虚拟，异步



#### 并发与并行的辨析：

并发是两个或多个事件在==同一时间间隔内==发生，实质是“宏观上都在运行，微观上交替执行”，而并行是两个或多个事件在==同一时刻==发生，实质是“多核CPU运行多道程序，同时执行，互不干扰”

并发 ——> 单核CPU，并行 ——> 多核CPU



#### 共享（针对系统资源来说的）

目的：使得系统中的资源，供内存中多个==并发执行==的进程共同使用

分为：互斥共享 和 同时访问

系统中某些资源，需要互斥共享（规定在一段时间内，只允许一个进程访问该资源），比如打印机，摄像头；而有些资源，允许一段时间内多个进程同时对他们进行访问（宏观上同时执行）（微观上不确定是交替还是同时），比如磁盘读取文件，扬声器。



#### 互斥共享 和 同时访问 的区别：

互斥共享：独占使用。（当资源被进程A占用时，进程B想用？没门！只能阻塞，直到A用完释放）

同时访问：允许并发，多方共用。（进程A在用，进程B也可以用。大家不用严格排队等对方彻底结束）



#### 虚拟

分为两种技术：时分复用，空分复用

时分复用：你只有一个单核CPU，但系统里开了100个进程，利用时间轮转法，让多个程序并发执行，每个进程都以为自己独占一个CPU。

空分复用：你物理内存只有8G，但你可以玩50G的游戏。实质是：操作系统在背后将数据在内存和外存之间来回倒腾（“缺页中断”和“置换算法”），让你以为内存无限大。



#### 异步 

在并发环境中，进程的执行不是一气呵成的，而是走走停停。

如果不加以管理，这会导致：同样的程序每一次的结果不同（结果不可再现性）。因此，我们需要进程同步机制（信号量，锁）。



## 处理机调度

### 进程切换与调度方式

![image-20251224003205290](操作系统.assets/image-20251224003205290.png)

![image-20251224003508227](操作系统.assets/image-20251224003508227.png)

![image-20251224003950622](操作系统.assets/image-20251224003950622.png)

![image-20251224003853819](操作系统.assets/image-20251224003853819.png)



### 调度算法的评价指标

1. CPU利用率

​	<img src="操作系统.assets/image-20251219113821555.png" alt="image-20251219113821555" style="zoom: 67%;" />

​	

2. 系统吞吐量

   <img src="操作系统.assets/image-20251219113933738.png" alt="image-20251219113933738" style="zoom:50%;" />

3. 周转时间

​	![image-20251219114142828](操作系统.assets/image-20251219114142828.png)

![image-20251219114316599](操作系统.assets/image-20251219114316599.png)



4. 等待时间

![image-20251219114732029](操作系统.assets/image-20251219114732029.png)



### 调度算法1（先来先服务，短作业优先，高响应比优先）

Tips：各种调度算法的学习思路

1. 算法思想 
2. 算法规则 
3. 这种调度算法是用于 作业调度 还是 进程调度？ 
4. 抢占式？非抢占式？ 
5. 优点和缺点 
6. 是否会导致饥饿 （某进程/作业长期 得不到服务）



#### 先来先服务（FCFS）



![image-20251219115633560](操作系统.assets/image-20251219115633560.png)

![image-20251219150404697](操作系统.assets/image-20251219150404697.png)



#### 短作业优先（抢占式、非抢占式）（SJF）

![image-20251219150559448](操作系统.assets/image-20251219150559448.png)

![image-20251219150934438](操作系统.assets/image-20251219150934438.png)

![image-20251219151108045](操作系统.assets/image-20251219151108045.png)



![image-20251219151403193](操作系统.assets/image-20251219151403193.png)



#### 高响应比优先（HRRN）

![image-20251219151841964](操作系统.assets/image-20251219151841964.png)

![image-20251219151813952](操作系统.assets/image-20251219151813952.png)



### 调度算法2（时间片轮转，优先级调度，多级反馈队列，多级队列）

#### 时间片轮转调度算法（RR）



当时间片为2时：

![image-20251219152800124](操作系统.assets/image-20251219152800124.png)

循环操作......，最终：

![image-20251219152928829](操作系统.assets/image-20251219152928829.png)



当时间片为5时：

![image-20251219153143775](操作系统.assets/image-20251219153143775.png)

与 “先来先服务” 调度算法对比：

![image-20251219153503094](操作系统.assets/image-20251219153503094.png)



![image-20251219153639694](操作系统.assets/image-20251219153639694.png)



#### 优先级调度算法（抢占式、非抢占式）



![image-20251219154100071](操作系统.assets/image-20251219154100071.png)

![image-20251219153911886](操作系统.assets/image-20251219153911886.png)



优先级调度算法可以分为：静态优先级、动态优先级

![image-20251219154519489](操作系统.assets/image-20251219154519489.png)

![image-20251219154625197](操作系统.assets/image-20251219154625197.png)



#### 多级反馈队列调度算法

![image-20251219155123960](操作系统.assets/image-20251219155123960.png)

![image-20251219155317574](操作系统.assets/image-20251219155317574.png)

#### 多级队列调度算法

![image-20251219172038789](操作系统.assets/image-20251219172038789.png)



## 进程同步问题

### 进程同步

假设你和你的伴侣共用一张银行卡，里面有1000块。

1. 你走到ATM机，读出余额：1000。准备取100。（此时CPU切换了！）
2. 伴侣在手机APP上，读出余额：1000。准备存100。
3. 伴侣的操作先完成：1000+100=11001000+100=1100。写入数据库。
4. 你的操作接着完成（你手里拿的数据还是旧的1000）：1000−100=9001000−100=900。写入数据库。

结果：数据库变成了900。伴侣存的那100块凭空消失了！

因此：如果不加控制，并发进程对共享数据（临界资源）的乱序访问，会导致数据不一致。所以我们需要“同步”。



**同步机制必须遵循的四条准则：**

- 空闲让进（没人用你就进）；
- 忙则等待（有人用你就等）；
- 有限等待（不能一直等）；
- 让权等待（等待的过程中，先把CPU让出，不能占着茅坑不拉屎）；



先来了解一下几个概念：

临界资源：一次只允许一个进程使用的资源

临界区：程序中访问临界资源的那段代码

信号量（分为：整型信号量，记录型信号量）：可用资源数量（负值表示：无可用资源，且存在资源请求）

原语：特殊的程序段，如果选择执行，则必须完全执行，不可中断

P操作（wait原语）：申请资源（进入区）

V操作（signal原语）：释放资源（退出区）





### 信号量机制





下边的三个模型（生产者-消费者问题，读者写者问题，哲学家进餐问题），都是解决：在并发进程中，资源共享的问题。（也就是说：在都是并发执行的情况下，不能产生 “死锁”（永远运行不了）现象）

### 经典模型1：生产者-消费者问题

有两个进程A和B，它们共享一个固定大小的缓冲区，A进程产生数据放入缓冲区，B进程从缓冲区中取出数据进行计算，那么这里其实就是一个生产者和消费者的模式，A相当于生产者，B相当于消费者。

要求：

- 只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。
- 只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。
- 缓冲区是临界资源，各进程必须互斥地访问。

<img src="操作系统.assets/image-20251218155906229.png" alt="image-20251218155906229" style="zoom: 67%;" />

在 “生产者-消费者” 模型中，存在两对重要关系：互斥关系，同步关系；

互斥关系描述的是：对临界资源的 “独占” ；

同步关系描述的是：进程执行，一前一后的关系；

![image-20251218161358578](操作系统.assets/image-20251218161358578.png)

<img src="操作系统.assets/image-20251218161105379.png" alt="image-20251218161105379" style="zoom:80%;" />



### 经典模型2：读者-写者问题

与“生产者-消费者”模型最大的不同在于：**读者之间不存在互斥关系**。

1. 读-读允许

2. 写-写互斥 

3. 读-写互斥 

   

<img src="操作系统.assets/image-20251219104222312.png" alt="image-20251219104222312" style="zoom: 67%;" />



### 经典模型3：哲学家进餐问题

![image-20251219104856798](操作系统.assets/image-20251219104856798.png)

若五位哲学家同时饥饿而各自拿起了左边的筷子，这使五个信号量 chopstick 均为 0，当他们试图去拿起右边的筷子时，都将因无筷子而无限期地等待下去，即可能会引起死锁。



哲学家进餐问题的改进解法

- 方法一：至多只允许四位哲学家同时去拿左筷子，最终能保证至少有一位哲学家能进餐，并在用完后释放两只筷子供他人使用。
- 方法二：仅当哲学家的左右手筷子都拿起时才允许进餐。
- 方法三：规定奇数号哲学家先拿左筷子再拿右筷子，而偶数号哲学家相反。



方法一的实现：

<img src="操作系统.assets/image-20251219105757817.png" alt="image-20251219105757817" style="zoom:67%;" />

原理：至多只允许四个哲学家同时进餐，以保证至少有一个哲学家能够进餐，最终总会释放出他所使用过的两支筷子，从而可使更多的哲学家进餐。



方法二的实现：

![image-20251219105629181](操作系统.assets/image-20251219105629181.png)

原理：通过互斥信号量 mutex 对 “取筷子” 的操作进行保护，可以防止死锁的出现。



方法三的实现：

<img src="操作系统.assets/image-20251219105902266.png" alt="image-20251219105902266" style="zoom:67%;" />



### 死锁

#### 死锁产生的必要条件（4个）：

1. 互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。
2. 不可剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。
3. 请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。（比如：哲学家进餐问题）
4. 环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。

#### 解决方法（3个）：

1. 预防死锁：可以通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或者几个，来预防发生死锁。

   预防死锁是一种较易实现的方法，已被广泛使用。但是由于所施加的限制条件往往太严格，可能会导致系统资源利用率和系统吞吐量降低

2. 死锁避免：系统对进程发出的每一个系统能够满足的资源申请进行**动态检查**，并根据检查结果决定是否分配资源；如果分配后系统可能发生死锁，则不予分配，否则予以分配。这是一种保证系统不进入死锁状态的**动态策略**。

3. 死锁检测和解除：这种方法并不事先采取任何限制性措施，此方法**允许系统在运行过程中发生死锁**。但可通过系统所设置的检测机制，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源。然后采取适当措施，从系统中将已发生的死锁清除掉。

   常用的实施方法是撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。死锁的检测和解除措施，有可能使系统获得较好的资源利用率和吞吐量，但在实现上难度也最大。



## 存储器管理

![image-20251220195137889](操作系统.assets/image-20251220195137889.png)

### 内存空间的分配

#### 连续分配（为用户进程分配连续的内存空间）

##### “紧凑”操作





##### 单一连续分配

![image-20251220201422102](操作系统.assets/image-20251220201422102.png)



##### 固定分区分配

![image-20251220201647876](操作系统.assets/image-20251220201647876.png)

![image-20251220201840385](操作系统.assets/image-20251220201840385.png)



##### 动态分区分配

![image-20251220202723602](操作系统.assets/image-20251220202723602.png)

动态分区分配算法分为4种：首次适应算法，循环首次适应算法，最佳适应算法，最坏适应算法；



###### 首次适应算法

算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。 

如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。



###### 循环首次适应算法

算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。 

如何实现：空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。



###### 最佳适应算法

算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，优先使用更小的空闲区。 

如何实现：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。

缺点：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的外部碎片。



###### 最坏适应算法

算法思想：为了解决最佳适应算法的问题 —— 即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。

如何实现：空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。

缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后有 “大进程” 到达，就没有内存分区可用了。



#### 非连续分配（离散存储方式）

###### 分页存储管理

将用户程序的地址空间分为若干个固定大小的区域，称为“页”或者“页面”。也将内存空间分为若干个 “物理块”或 “页框” ，页和框的大小相同（一一对应）。

![image-20251220210535102](操作系统.assets/image-20251220210535102.png)

![image-20251220210919467](操作系统.assets/image-20251220210919467.png)

![image-20251220211333316](操作系统.assets/image-20251220211333316.png)

![image-20251220211511701](操作系统.assets/image-20251220211511701.png)

如果每个页面大小为 2ᵏB，用二进制数表示逻辑地址，则末尾 k 位即为页内偏移量，其余部分就是页号



![image-20251220212540540](操作系统.assets/image-20251220212540540.png)

![image-20251220213008730](操作系统.assets/image-20251220213008730.png)

![image-20251220213326446](操作系统.assets/image-20251220213326446.png)

![image-20251221200427138](操作系统.assets/image-20251221200427138.png)

![image-20251221201050041](操作系统.assets/image-20251221201050041.png)



###### 分段存储管理

![image-20251221201424028](操作系统.assets/image-20251221201424028.png)

![image-20251221201752441](操作系统.assets/image-20251221201752441.png)

![image-20251221202120786](操作系统.assets/image-20251221202120786.png)

![image-20251221202326780](操作系统.assets/image-20251221202326780.png)

![image-20251221202649510](操作系统.assets/image-20251221202649510.png)

![image-20251221202759246](操作系统.assets/image-20251221202759246.png)

![image-20251221202852283](操作系统.assets/image-20251221202852283.png)



###### 段页式存储管理

![image-20251221203132497](操作系统.assets/image-20251221203132497.png)

![image-20251221203307519](操作系统.assets/image-20251221203307519.png)

![image-20251221203708334](操作系统.assets/image-20251221203708334.png)

![image-20251221203924823](操作系统.assets/image-20251221203924823.png)



## 虚拟存储

![image-20251221205101077](操作系统.assets/image-20251221205101077.png)

![image-20251221205220438](操作系统.assets/image-20251221205220438.png)

![image-20251221205342546](操作系统.assets/image-20251221205342546.png)

![image-20251221205526556](操作系统.assets/image-20251221205526556.png)

### 请求分页管理方式

**请求分页 = 基本分页 + “虚拟内存技术”（缺页中断 + 页面置换）**

![image-20251224011214679](操作系统.assets/image-20251224011214679.png)

![image-20251224011451777](操作系统.assets/image-20251224011451777.png)

![image-20251224011623663](操作系统.assets/image-20251224011623663.png)

![image-20251224011834043](操作系统.assets/image-20251224011834043.png)



### 页面置换算法

#### 最佳置换算法（OPT）

![image-20251224023153346](操作系统.assets/image-20251224023153346.png)

#### 先进先出置换算法（FIFO）

![image-20251224023323881](操作系统.assets/image-20251224023323881.png)

![image-20251224023444395](操作系统.assets/image-20251224023444395.png)



#### 最近最久未使用置换算法（LRU）

![image-20251224023828532](操作系统.assets/image-20251224023828532.png)

#### 最近未使用算法（NRU）（时钟置换算法）

![image-20251224024254646](操作系统.assets/image-20251224024254646.png)

![image-20251224024700203](操作系统.assets/image-20251224024700203.png)



# 考试题目预测：

## 什么是“与时间有关的错误”？举例并解决

### 1. 什么是“与时间有关的错误”？

**定义**：
在多道程序环境下，多个进程并发执行时，如果不加控制地共享数据（变量、文件等），由于进程执行的**相对速度无法预测**（即 CPU 随时可能切换），导致程序运行的结果**不确定**。

**特点**：

*   **结果不可再现**：同样的输入，这次跑是对的，下次跑可能就是错的。

---

### 2. 经典举例（必背例子：售票/计数器）

假设有一个全局变量 `count = 10`，表示剩余票数。
进程 A 和进程 B 都想卖出一张票（即执行 `count = count - 1`）。

**理想情况（正确结果）**：
A 卖一张（10->9），B 卖一张（9->8）。最后 `count` 应该是 **8**。

**出错情况（错误结果）**：
`count = count - 1` 这行代码在计算机底层其实分三步走：

1.  **LOAD**: 把 count 的值读入 CPU 寄存器。
2.  **SUB**: 寄存器里的值减 1。
3.  **STORE**: 把寄存器里的值写回内存的 count。

如果 CPU 调度发生了如下的**交替执行**：

| 时间 | 进程 A 的动作      | 进程 B 的动作     | 内存中 count 的值 | 备注                  |
| :--- | :----------------- | :---------------- | :---------------- | :-------------------- |
| 1    | **LOAD**: 读到 10  | (等待)            | 10                | A 记住了 10           |
| 2    | (时间片用完，切换) | **LOAD**: 读到 10 | 10                | **B 也读到了 10！**   |
| 3    | (等待)             | **SUB**: 10-1 = 9 | 10                | B 算出了 9            |
| 4    | (等待)             | **STORE**: 写回 9 | **9**             | B 任务完成            |
| 5    | **SUB**: 10-1 = 9  | (等待)            | 9                 | **A 还在用旧值算！**  |
| 6    | **STORE**: 写回 9  | (等待)            | **9**             | **A 覆盖了 B 的结果** |

**结果**：两个进程各卖了一张票，但总数只减了 1。这就是“与时间有关的错误”。

---

### 3. 如何解决？（互斥锁 / PV操作）

**考场通用解法（PV操作模板）**：

1.  **定义互斥信号量**：`semaphore mutex = 1;` （表示锁有一把，初值为1）
2.  **加锁（P操作/wait）**：在访问共享变量**之前**。
3.  **解锁（V操作/signal）**：在访问共享变量**之后**。

**修正后的代码：**

```c
// 进程 A
P(mutex);       // 【关门】如果有人在里面，我就等待；没人在，我进去并锁门
count = count - 1; // 【临界区】现在只有我能动 count，爱怎么改怎么改，不用担心被打断
V(mutex);       // 【开门】改完了，释放锁，唤醒外面排队的人

// 进程 B
P(mutex);       // 【关门】如果 A 在里面，B 就会卡在这里阻塞，直到 A 执行 V(mutex)
count = count - 1;
V(mutex);       // 【开门】
```

### 总结

*   **名词解释**：并发进程竞争共享资源，因执行顺序不同导致结果不确定。
*   **例子**：两个进程同时 `count--`，结果只减了一次。
*   **解决**：使用**信号量（PV操作）**实现**互斥**，将共享数据的操作放入**临界区**。



![image-20251224000953092](操作系统.assets/image-20251224000953092.png)

![image-20251224001013826](操作系统.assets/image-20251224001013826.png)

## 银行家算法

<img src="操作系统.assets/image-20251224042714010.png" alt="image-20251224042714010" style="zoom:50%;" />

### **准备工作：计算需求矩阵（Need）**

在回答问题之前，必须先算出每个进程还“需要”多少资源。
公式：$Need = Max - Allocation$ （最大需求 - 已占有）

我们把计算结果列在旁边：
*   **P1 Need**: $(0,0,1,2) - (0,0,1,2) = (0, 0, 0, 0)$
*   **P2 Need**: $(1,7,5,0) - (1,0,0,0) = (0, 7, 5, 0)$
*   **P3 Need**: $(2,3,5,6) - (1,3,5,4) = (1, 0, 0, 2)$
*   **P4 Need**: $(0,6,5,2) - (0,6,3,2) = (0, 0, 2, 0)$
*   **P5 Need**: $(0,6,5,6) - (0,0,1,4) = (0, 6, 4, 2)$

---

### **(1) 现在系统中的各类资源还剩余多少？**

**解题思路**：
剩余资源（Available） = 资源总数（Total） - 所有进程已占用的总和（Sum of Allocation）。

1.  **统计已占有资源总量**（把表格里“已占有资源”那一列竖着加起来）：
    *   A = $0+1+1+0+0 = 2$
    *   B = $0+0+3+6+0 = 9$
    *   C = $1+0+5+3+1 = 10$
    *   D = $2+0+4+2+4 = 12$
    *   已占用总和 = $(2, 9, 10, 12)$

2.  **计算剩余资源**：
    *   Total = $(3, 14, 12, 12)$
    *   Available = Total - 已占用
    *   Available = $(3, 14, 12, 12) - (2, 9, 10, 12) = (1, 5, 2, 0)$

**答案 (1)：**
**现在系统中的各类资源剩余量（Available）为：A=1, B=5, C=2, D=0。即向量 $(1, 5, 2, 0)$。**

---

### **(2) 现在系统是否处于安全状态？为什么？**

**解题思路**：
利用**安全性算法**。尝试找出一个**安全序列**，即：有没有办法让所有进程一个接一个地执行完？
*   当前手里有：Available = $(1, 5, 2, 0)$
*   规则：如果你手里的资源 $\ge$ 某进程的 Need，就可以让它跑。跑完后收回它的所有 Allocation 资源。

**推导过程（必写步骤）：**

1.  **检查 P1**：
    *   Need $(0,0,0,0) \le$ Available $(1,5,2,0)$？**满足**。
    *   P1 执行完释放资源：Available = $(1,5,2,0) + P1已占有(0,0,1,2) = (1, 5, 3, 2)$。

2.  **检查 P4**（看 Need 比较小的）：
    *   Need $(0,0,2,0) \le$ 当前 Available $(1,5,3,2)$？**满足**。
    *   P4 执行完释放资源：Available = $(1,5,3,2) + P4已占有(0,6,3,2) = (1, 11, 6, 4)$。

3.  **检查 P3**：
    *   Need $(1,0,0,2) \le$ 当前 Available $(1,11,6,4)$？**满足**。
    *   P3 执行完释放资源：Available = $(1,11,6,4) + P3已占有(1,3,5,4) = (2, 14, 11, 8)$。

4.  **检查 P5**：
    *   Need $(0,6,4,2) \le$ 当前 Available $(2,14,11,8)$？**满足**。
    *   P5 执行完释放资源：Available = $(2,14,11,8) + P5已占有(0,0,1,4) = (2, 14, 12, 12)$。

5.  **检查 P2**：
    *   Need $(0,7,5,0) \le$ 当前 Available $(2,14,12,12)$？**满足**。
    *   P2 执行完释放资源：Available = $(3, 14, 12, 12)$ （全部回收）。

**答案 (2)：**
**系统处于安全状态。**
**原因：存在一个安全序列 $\{P1, P4, P3, P5, P2\}$（注：顺序不唯一，只要能跑通就行），所有进程都能顺利执行完毕。**

---

### **(3) 如果 P2 提出请求 (0, 4, 2, 0)，系统能否满足？**

**解题思路**：
这是典型的**银行家算法**请求检查。分三步走：
1.  **查合法性**：请求 $\le$ Need？请求 $\le$ Available？
2.  **试探分配**：假装把资源分给它，算出新的状态。
3.  **查安全性**：在新的状态下，还能不能找到安全序列？

**步骤详解：**

1.  **检查合法性**：
    *   Request $(0,4,2,0) \le Need_{P2} (0,7,5,0)$？ **满足**。
    *   Request $(0,4,2,0) \le Available (1,5,2,0)$？ **满足**（B: 4<5, C: 2=2）。

2.  **试探性分配（修改数据）**：
    *   **Available** 变少：$(1,5,2,0) - (0,4,2,0) = (1, 1, 0, 0)$
    *   **P2 Allocation** 变多：$(1,0,0,0) + (0,4,2,0) = (1, 4, 2, 0)$
    *   **P2 Need** 变少：$(0,7,5,0) - (0,4,2,0) = (0, 3, 3, 0)$

3.  **安全性检测（关键！）**：
    *   现在系统手里只剩 **Work = $(1, 1, 0, 0)$**。
    *   我们看看凭借这仅有的资源，能不能活下去？

    *   **第一步：找 P1**
        *   Need $(0,0,0,0) \le Work (1,1,0,0)$。**满足**。
        *   回收 P1：Work = $(1,1,0,0) + (0,0,1,2) = (1, 1, 1, 2)$。

    *   **第二步：找 P3** (P2不行因C不够，P4不行因C不够，P5不行因C不够)
        *   Need $(1,0,0,2) \le Work (1,1,1,2)$。**满足**（注意：P3需要D=2，手里刚好有2）。
        *   回收 P3：Work = $(1,1,1,2) + (1,3,5,4) = (2, 4, 6, 6)$。

    *   **第三步：找 P4**
        *   Need $(0,0,2,0) \le Work (2,4,6,6)$。**满足**。
        *   回收 P4：Work = $(2,4,6,6) + (0,6,3,2) = (2, 10, 9, 8)$。

    *   **后续**：这时候资源已经很多了，P5 和 P2 都可以随便满足。

**答案 (3)：**
**系统能满足 P2 的请求。**
**原因：**
1.  请求合法（不大于 Need 且不大于 Available）。
2.  试探分配后，系统Available变为 $(1,1,0,0)$。
3.  在此状态下，系统仍存在安全序列（例如 $\{P1, P3, P4, P5, P2\}$），因此系统是安全的，可以分配。

## 进程同步问题

![image-20251224043641205](操作系统.assets/image-20251224043641205.png)

这是一道**非常典型但有一个关键陷阱**的题目。

这类题通常考的是“有界缓冲区”（即缓冲区大小为N），但这道题明确说了**“缓冲区无限大”**。这意味着：**生产者永远不需要等待空位（不用 P(empty)），但消费者仍然需要等待产品（需要 P(full)）。**

只要抓住这个区别，这道题就是满分。

以下是标准答题模板：

---

### 一、 信号量设置及物理含义

我们需要定义两个信号量：

1.  **`mutex`**：
    *   **初值**：1
    *   **物理含义**：互斥信号量，用于实现对缓冲区的互斥访问（防止生产者和消费者同时操作指针把数据搞乱）。
2.  **`full`**：
    *   **初值**：0
    *   **物理含义**：资源信号量，表示当前缓冲区中**已有产品的数量**（即消费者可消费的数量）。

> **注意**：这里**不需要**设置 `empty` 信号量，因为题目说缓冲区无限大，意味着永远有空位，生产者永远不会因为“满了”而阻塞。

---

### 二、 同步控制算法描述

```c
// 生产者进程 (Producer)
while (true) {
    produce();          // 生产一个产品
    
    // 关键点：因为无限大，所以不需要 P(empty)
    
    P(mutex);           // 【申请锁】进入临界区
    put();              // 将产品放入缓冲区
    V(mutex);           // 【释放锁】退出临界区
    
    V(full);            // 【释放资源】产品数 +1，唤醒可能在等待的消费者
}

// 消费者进程 (Consumer)
while (true) {
    P(full);            // 【申请资源】检查有没有产品？没产品就阻塞等待
    
    P(mutex);           // 【申请锁】进入临界区
    take();             // 从缓冲区取出一个产品
    V(mutex);           // 【释放锁】退出临界区
    
    // 关键点：因为无限大，不需要 V(empty) 通知生产者有空位
    
    consume();          // 消费产品
}
```

**简单总结**：
这题就是把标准的“生产者-消费者”代码中，关于 **`empty`** 的所有操作（P和V）统统删掉即可！



## 分页存储管理

![image-20251224082522532](操作系统.assets/image-20251224082522532.png)

---

### **第一问：基础参数计算**

**(1) 该系统的内存空间大小是多少？**
*   **思路**：物理地址决定了物理内存的总容量。
*   **计算**：物理地址占 20 位，说明能寻址 $2^{20}$ 个单元。通常按字节编址。
    $$2^{20} \text{ Byte} = 1 \text{ MB}$$
*   **答案**：**1MB**

**(2) 每个物理块的大小是多少？**
*   **思路**：在分页系统中，**页的大小（逻辑） = 块的大小（物理）**，这是基本铁律，否则装不进去。
*   **计算**：题目给出“页大小为 1KB”。
*   **答案**：**1KB**

**(3) 逻辑地址共几位？**
*   **思路**：逻辑地址 = 页号部分 + 页内偏移量部分。
*   **计算**：
    1.  页大小为 1KB = $2^{10}$ B，说明**页内偏移量（页内地址）需要 10 位**。
    2.  题目直接给出“页号占 6 位”。
    3.  总位数 = 页号位数 + 页内偏移位数 = $6 + 10 = 16$ 位。
*   **答案**：**16位**

**(4) 每个作业最大长度是多少？**
*   **思路**：作业最大长度就是逻辑地址空间的大小。
*   **计算**：逻辑地址共 16 位，所以最大长度为 $2^{16}$ B。
    $$2^{16} \text{ B} = 64 \text{ KB}$$
*   **答案**：**64KB**

---

### **第二问：地址映射计算（重难点）**

**题目**：逻辑地址 **0420H** 对应的物理地址是什么？说明映射过程。

**解题步骤：**

**第一步：拆分逻辑地址（切西瓜法）**
我们要把十六进制的 `0420H` 拆成“页号”和“页内偏移”。
*   逻辑地址总共 16 位，其中**低 10 位是页内偏移**，**高 6 位是页号**。
*   将 `0420H` 展开为二进制：
    `0000 0100 0010 0000`
*   **切分**（右边数10位砍一刀）：
    *   **页号（P）**：`0000 01` $\rightarrow$ 十进制是 **1**。
    *   **页内偏移（W）**：`00 0010 0000` $\rightarrow$ 十六进制是 **020H**。

**第二步：查页表（找替身）**
根据题目给出的条件：
*   0 页放在 3 块
*   **1 页放在 10 块** （我们需要这个！）
*   2 页放在 9 块

既然页号是 **1**，对应的物理块号（Block Number）就是 **10**。
（注意：这里的10是十进制，转换为十六进制是 **0AH**）。

**第三步：拼接物理地址**
*   **公式**：物理地址 = 块号 $\times$ 块大小 + 页内偏移
    （或者直接在二进制层面拼接：块号拼上偏移量）
*   **计算方法 A（推荐用二进制拼接，不易出错）：**
    *   物理块号 10 (十进制) $\rightarrow$ 二进制 `00 0000 1010` (物理地址共20位，去掉10位偏移，块号占高10位)。
    *   页内偏移 020H $\rightarrow$ 二进制 `00 0010 0000`。
    *   **拼接**：
        `0000 0010 10` (块号) `00 0010 0000` (偏移)
        Wait，这不对，要按位对齐。物理地址高位是块号，低10位是偏移。
        块号是10 -> `1010` (二进制)。
        因为物理地址20位，偏移10位，所以块号放在第11-20位。
        
        二进制串：`0000 0010 1000 0010 0000`
        （高10位是10，低10位是32）
        
        每4位转成一个十六进制数：
        `0000` -> **0**
        `0010` -> **2**
        `1000` -> **8**
        `0010` -> **2**
        `0000` -> **0**
        
        结果：**02820H**

*   **计算方法 B（十进制算完转十六进制）：**
    *   物理地址 = $10 \times 1024 + 32$ （020H是32）
    *   $= 10240 + 32 = 10272$
    *   将 10272 转为十六进制 $\rightarrow$ **2820H**

---

### **最终答案整理**

1.  **内存空间大小**：1MB
2.  **物理块大小**：1KB
3.  **逻辑地址位数**：16位
4.  **作业最大长度**：64KB
5.  **物理地址**：**02820H** （或者写 2820H）
6.  **地址映射过程**：
    *   将逻辑地址 0420H 分解，得到页号为 1，页内偏移为 020H。
    *   检索页表，页号 1 对应的物理块号为 10（十进制）。
    *   将物理块号 10 转换为物理地址的高位，加上页内偏移量。
    *   计算得出物理地址为 02820H。



## 进程状态转化图

![image-20251224083543493](操作系统.assets/image-20251224083543493.png)

```Mermaid
graph TD
    A((就绪状态 Ready))
    B((运行状态 Running))
    C((阻塞状态 Blocked))
A -- "进程调度 (Dispatch)" --> B
B -- "时间片用完 (Time Slice Expiration)" --> A
B -- "I/O请求 / 等待事件" --> C
C -- "I/O完成 (提升优先级/插队)" --> A
```

![image-20251224085551241](操作系统.assets/image-20251224085551241.png)

### 💡 简易版答案（考场速记）

如果你觉得上面太长，考试时可以简写成链条形式，清晰明了：

1.  **就绪 $\rightarrow$ 运行**：被调度程序选中。
2.  **运行 $\rightarrow$ 就绪**：时间片用完（**注意：因是计算密集型，此过程可能重复**）。
3.  **运行 $\rightarrow$ 阻塞**：请求 I/O 输出结果。
4.  **阻塞 $\rightarrow$ 就绪**：I/O 输出完成。
5.  **就绪 $\rightarrow$ 运行**：再次被调度。
6.  **运行 $\rightarrow$ 终止**：执行 `return 0`，进程结束。

## PPT两道题目

![image-20251224093339491](操作系统.assets/image-20251224093339491.png)

---

### **示例题一：多用户文书编辑系统**

**答：操作系统需提供以下 5 点支持：**

1.  **用户接口**：提供终端（命令行或窗口），让用户能输入命令。
2.  **处理器管理**：采用**时间片轮转调度**，保证多个用户打字时都能得到及时响应（不卡顿）。
3.  **存储管理**：进行内存分配，并实现**内存保护**（隔离各用户，防止数据互相干扰）。
4.  **文件管理**：提供文档的保存/读取功能，并设置**存取权限**（防止偷看别人文件）。
5.  **设备管理**：处理键盘输入和屏幕显示的**中断**与控制。

---

### **示例题二：长短进程混合调度**

#### **(1) 是否需要在 PCB 中规定优先级？为什么？**
*   **答：需要。**
*   **原因**：因为有长短两类进程，为了提高系统吞吐量和响应速度，系统必须能区分它们，赋予短进程**更高的优先级**。

#### **(2) 设计算法（兼具效率与公平）**
*   **算法名称**：**多级反馈队列调度算法**（必背）。
*   **设计方案**：
    1.  **多队列**：设置多个就绪队列（如 Q1, Q2, Q3），优先级 Q1 > Q2 > Q3。
    2.  **不同时间片**：优先级越高，时间片越短（Q1 最短）；优先级越低，时间片越长。
    3.  **规则**：新进程进 Q1。若 Q1 时间片用完没跑完，**降级**到 Q2，以此类推。
*   **效果**：短进程在 Q1 快速完成（效率）；长进程在 Q3 获得长的时间片（公平，不饿死）。

#### **(3) 状态转换及原因**
*   **就绪 $\rightarrow$ 运行**：进程被调度程序选中。
*   **运行 $\rightarrow$ 就绪**：**时间片用完**（这是多级反馈队列的核心，未运行完被剥夺并降级）。
*   **运行 $\rightarrow$ 阻塞**：请求 I/O 操作。
*   **阻塞 $\rightarrow$ 就绪**：I/O 操作完成。
*   **运行 $\rightarrow$ 终止**：进程执行结束。
